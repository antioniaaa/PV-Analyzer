package de.anton.pv.analyser.pv_analyzer.view;

import de.anton.pv.analyser.pv_analyzer.model.CalculatedDataPoint;
import de.anton.pv.analyser.pv_analyzer.algorithms.MyOPTICS;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.table.*;
import java.awt.*;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Dialog window displaying analysis data points, visually grouped by orientation.
 * Includes the source timestamp, performance label, and other metrics.
 */
public class TableDialog extends JDialog {

    private final JTable dataTable;
    private final DataTableModel tableModel;
    private final boolean moduleInfoAvailable;

    public TableDialog(Frame owner, boolean moduleInfoAvailable) {
        super(owner, "Daten-Tabelle (gruppiert nach Ausrichtung)", false);
        this.moduleInfoAvailable = moduleInfoAvailable;
        tableModel = new DataTableModel(moduleInfoAvailable);
        dataTable = new JTable(tableModel); dataTable.setAutoCreateRowSorter(true); dataTable.setFillsViewportHeight(true); dataTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF); dataTable.setDefaultRenderer(Object.class, new GroupedHighlightRenderer());
        setupColumnWidths();
        JScrollPane scrollPane = new JScrollPane(dataTable); add(scrollPane, BorderLayout.CENTER);
        setSize(1650, 550); setMinimumSize(new Dimension(850, 300)); setLocationByPlatform(true);
    }

    private void setupColumnWidths() {
        TableColumnModel columnModel = dataTable.getColumnModel();
        try { int colIdx = 0; columnModel.getColumn(colIdx++).setPreferredWidth(100); columnModel.getColumn(colIdx++).setPreferredWidth(140); columnModel.getColumn(colIdx++).setPreferredWidth(180); columnModel.getColumn(colIdx++).setPreferredWidth(110); columnModel.getColumn(colIdx++).setPreferredWidth(110); columnModel.getColumn(colIdx++).setPreferredWidth(90); columnModel.getColumn(colIdx - 1).setMaxWidth(110); columnModel.getColumn(colIdx++).setPreferredWidth(110); columnModel.getColumn(colIdx++).setPreferredWidth(110); columnModel.getColumn(colIdx++).setPreferredWidth(100); columnModel.getColumn(colIdx++).setPreferredWidth(100); columnModel.getColumn(colIdx++).setPreferredWidth(80); columnModel.getColumn(colIdx - 1).setMaxWidth(100); if (moduleInfoAvailable) { columnModel.getColumn(colIdx++).setPreferredWidth(100); columnModel.getColumn(colIdx++).setPreferredWidth(140); columnModel.getColumn(colIdx++).setPreferredWidth(140); columnModel.getColumn(colIdx++).setPreferredWidth(150); } columnModel.getColumn(colIdx).setPreferredWidth(90); columnModel.getColumn(colIdx).setMaxWidth(120); colIdx++; columnModel.getColumn(colIdx).setPreferredWidth(80); columnModel.getColumn(colIdx).setMaxWidth(100); colIdx++; }
        catch (ArrayIndexOutOfBoundsException e) { System.err.println("Warning: Error setting column widths in TableDialog: " + e.getMessage()); }
    }

    public void updateData(List<CalculatedDataPoint> data) { if (!SwingUtilities.isEventDispatchThread()) { SwingUtilities.invokeLater(() -> updateData(data)); return; } List<CalculatedDataPoint> sortedData; if (data == null) { sortedData = new ArrayList<>(); } else { Comparator<CalculatedDataPoint> comparator = Comparator .<CalculatedDataPoint, String>comparing(CalculatedDataPoint::getAusrichtung, String.CASE_INSENSITIVE_ORDER) .thenComparing(CalculatedDataPoint::getSourceTimestamp, Comparator.nullsLast(String::compareTo)) .thenComparing(CalculatedDataPoint::getName, String.CASE_INSENSITIVE_ORDER); sortedData = data.stream().filter(Objects::nonNull).sorted(comparator).collect(Collectors.toList()); } tableModel.setData(sortedData); setTitle("Daten-Tabelle (gruppiert, " + sortedData.size() + " Punkte)"); }
    public boolean isModuleInfoAvailable() { return moduleInfoAvailable; }

    private static class DataTableModel extends AbstractTableModel {
        private List<CalculatedDataPoint> data = new ArrayList<>(); private final boolean moduleInfoAvailable; private Map<String, Integer> orientationParityMap = new HashMap<>();
        private static final List<String> COLUMN_NAMES_STRUCTURE = List.of("Ausrichtung", "Zeitstempel (Quelle)"); private static final List<String> COLUMN_NAMES_BASE = List.of( "Name", "DC-Leistung (kW)", "Spez. Leistung (kW/kWp)", "Performance", "DC-Spannung (V)", "Nennleistung (kWp)", "Strom/String (A)", "Ohm (Ω)", "Anzahl Strings"); private static final List<String> COLUMN_NAMES_MODULE = List.of( "Module/String", "Diff Spannung (Modul-Vmpp)", "Diff Strom (Modul-Impp)", "Diff Leistung (Modul-Pmpp)"); private static final List<String> COLUMN_NAMES_END = List.of( "Cluster Gruppe", "Ausreißer?"); private final List<String> columnNamesCombined;
        public DataTableModel(boolean moduleInfoAvailable) { this.moduleInfoAvailable = moduleInfoAvailable; List<String> combined = new ArrayList<>(COLUMN_NAMES_STRUCTURE); combined.addAll(COLUMN_NAMES_BASE); if (moduleInfoAvailable) combined.addAll(COLUMN_NAMES_MODULE); combined.addAll(COLUMN_NAMES_END); this.columnNamesCombined = Collections.unmodifiableList(combined); }
        public void setData(List<CalculatedDataPoint> sortedData) { this.data = sortedData != null ? sortedData : new ArrayList<>(); calculateOrientationParities(this.data); fireTableDataChanged(); }
        private void calculateOrientationParities(List<CalculatedDataPoint> sortedData) { orientationParityMap.clear(); if (sortedData == null || sortedData.isEmpty()) return; String lastOrientation = null; int currentParity = 0; for (CalculatedDataPoint point : sortedData) { String currentOrientation = point.getAusrichtung(); if (currentOrientation == null) continue; if (!currentOrientation.equals(lastOrientation)) { if (lastOrientation != null) currentParity = 1 - currentParity; orientationParityMap.put(currentOrientation, currentParity); lastOrientation = currentOrientation; } orientationParityMap.putIfAbsent(currentOrientation, currentParity); } }
        public int getOrientationParity(String orientation) { return orientationParityMap.getOrDefault(orientation, 0); }
        @Override public int getRowCount() { return data.size(); } @Override public int getColumnCount() { return columnNamesCombined.size(); } @Override public String getColumnName(int column) { return columnNamesCombined.get(column); }
        @Override public Class<?> getColumnClass(int columnIndex) { String colName = getColumnName(columnIndex); if (colName.equals("Ausrichtung") || colName.equals("Zeitstempel (Quelle)") || colName.equals("Name") || colName.equals("Performance") || colName.equals("Ausreißer?")) return String.class; if (colName.equals("Anzahl Strings") || colName.equals("Cluster Gruppe")) return Integer.class; return Double.class; }
        @Override public Object getValueAt(int rowIndex, int columnIndex) { if (rowIndex < 0 || rowIndex >= data.size()) return null; CalculatedDataPoint point = data.get(rowIndex); if (point == null) return null; String colName = getColumnName(columnIndex); try { switch (colName) { case "Ausrichtung": return point.getAusrichtung(); case "Zeitstempel (Quelle)": return point.getSourceTimestamp(); case "Name": return point.getName(); case "DC-Leistung (kW)": return formatDouble(point.getDcLeistungKW()); case "Spez. Leistung (kW/kWp)": return formatDouble(point.getSpezifischeLeistung()); case "Performance": return point.getPerformanceLabel(); case "DC-Spannung (V)": return formatDouble(point.getDcSpannungV()); case "Nennleistung (kWp)": return formatDouble(point.getNennleistungKWp()); case "Strom/String (A)": return formatDouble(point.getStromJeStringA()); case "Ohm (Ω)": return formatDouble(point.getOhm()); case "Anzahl Strings": return point.getAnzahlStrings(); case "Module/String": return moduleInfoAvailable ? formatDouble(point.getAnzahlModuleJeString()) : null; case "Diff Spannung (Modul-Vmpp)": return moduleInfoAvailable ? formatDouble(point.getDiffSpannungModulVmpp()) : null; case "Diff Strom (Modul-Impp)": return moduleInfoAvailable ? formatDouble(point.getDiffStromModulImpp()) : null; case "Diff Leistung (Modul-Pmpp)": return moduleInfoAvailable ? formatDouble(point.getDiffLeistungModulPmpp()) : null; case "Cluster Gruppe": return point.getClusterGroup(); case "Ausreißer?": return point.isOutlier() ? "Ja" : "Nein"; default: System.err.println("Warning: Unhandled column name in DataTableModel: " + colName); return null; } } catch (Exception e) { System.err.println("Error getting value for row " + rowIndex + ", col " + columnIndex + " (" + colName + "): " + e.getMessage()); return null; } }
        private Double formatDouble(double value) { return Double.isNaN(value) ? null : value; } public CalculatedDataPoint getDataPointAt(int modelRowIndex) { return (modelRowIndex >= 0 && modelRowIndex < data.size()) ? data.get(modelRowIndex) : null; }
    }
    private static class GroupedHighlightRenderer extends DefaultTableCellRenderer { private static final Color OUTLIER_BACKGROUND = new Color(255, 200, 200); private static final Color NOISE_FOREGROUND = Color.DARK_GRAY; private static final Color SEPARATOR_COLOR = Color.GRAY; private static final Color ROW_COLOR_EVEN_OPAQUE = new Color(242, 245, 250); private static final Color ROW_COLOR_ODD_OPAQUE = null; private static final Color[] BASE_CLUSTER_COLORS = { new Color(31, 119, 180), new Color(255, 127, 14), new Color(44, 160, 44), new Color(214, 39, 40), new Color(148, 103, 189), new Color(140, 86, 75), new Color(227, 119, 194), new Color(127, 127, 127), new Color(188, 189, 34), new Color(23, 190, 207), Color.BLUE.darker(), Color.RED.darker(), Color.GREEN.darker(), Color.ORANGE.darker(), Color.MAGENTA.darker(), Color.CYAN.darker() }; private static final List<Color> CLUSTER_BG_COLORS_OPAQUE = new ArrayList<>(); static { for (Color baseColor : BASE_CLUSTER_COLORS) { int r = (baseColor.getRed() + 255 * 2) / 3; int g = (baseColor.getGreen() + 255 * 2) / 3; int b = (baseColor.getBlue() + 255 * 2) / 3; CLUSTER_BG_COLORS_OPAQUE.add(new Color(r, g, b)); } } private static final Color CLUSTER_NOISE_BACKGROUND_OPAQUE = new Color(235, 235, 235); private static final DecimalFormat FORMATTER_GENERAL = new DecimalFormat("#,##0.###"); private static final DecimalFormat FORMATTER_POWER = new DecimalFormat("#,##0.000"); private static final DecimalFormat FORMATTER_VOLTAGE = new DecimalFormat("#,##0.0"); private static final DecimalFormat FORMATTER_CURRENT = new DecimalFormat("#,##0.00"); private static final DecimalFormat FORMATTER_OHM = new DecimalFormat("#,##0.0"); private static final DecimalFormat FORMATTER_SPEC = new DecimalFormat("0.000"); @Override public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { Component cellComponent = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column); if (cellComponent instanceof JComponent) { ((JComponent) cellComponent).setOpaque(true); } setBorder(noFocusBorder); DataTableModel model = (DataTableModel) table.getModel(); int modelRow = table.convertRowIndexToModel(row); CalculatedDataPoint point = model.getDataPointAt(modelRow); String columnName = model.getColumnName(column); Color finalBackground = isSelected ? table.getSelectionBackground() : table.getBackground(); Color finalForeground = isSelected ? table.getSelectionForeground() : table.getForeground(); if (point == null) { setText(""); finalBackground = isSelected ? table.getSelectionBackground() : ((row % 2 == 0) ? ROW_COLOR_EVEN_OPAQUE : table.getBackground()); } else { if (!isSelected) { int orientationParity = model.getOrientationParity(point.getAusrichtung()); finalBackground = (orientationParity == 0) ? ROW_COLOR_EVEN_OPAQUE : table.getBackground(); finalForeground = table.getForeground(); if (columnName.equals("Cluster Gruppe")) { int clusterId = point.getClusterGroup(); if (clusterId == MyOPTICS.NOISE) { finalBackground = CLUSTER_NOISE_BACKGROUND_OPAQUE; finalForeground = NOISE_FOREGROUND; } else if (clusterId >= 0) { finalBackground = CLUSTER_BG_COLORS_OPAQUE.get(clusterId % CLUSTER_BG_COLORS_OPAQUE.size()); } } else if (point.isOutlier()) { finalBackground = OUTLIER_BACKGROUND; } if (finalForeground == null) { finalForeground = table.getForeground(); } } if (cellComponent instanceof JLabel) { JLabel label = (JLabel) cellComponent; label.setHorizontalAlignment(JLabel.LEFT); if (value instanceof Number && !(columnName.equals("Cluster Gruppe") || columnName.equals("Anzahl Strings"))) { label.setHorizontalAlignment(JLabel.RIGHT); DecimalFormat formatter; if (columnName.contains("Leistung (kW)") || columnName.contains("Leistung (Modul-Pmpp)")) formatter = FORMATTER_POWER; else if (columnName.contains("Spannung")) formatter = FORMATTER_VOLTAGE; else if (columnName.contains("Strom")) formatter = FORMATTER_CURRENT; else if (columnName.contains("Ohm")) formatter = FORMATTER_OHM; else if (columnName.contains("Spez.")) formatter = FORMATTER_SPEC; else formatter = FORMATTER_GENERAL; label.setText(formatter.format(value)); } else if (columnName.equals("Cluster Gruppe")) { label.setHorizontalAlignment(JLabel.CENTER); if (value instanceof Integer) { int group = (Integer) value; label.setText(group == MyOPTICS.NOISE ? "Noise" : String.valueOf(group)); } else { label.setText(""); } } else if (columnName.equals("Anzahl Strings") || columnName.equals("Ausrichtung") || columnName.equals("Zeitstempel (Quelle)") || columnName.equals("Performance")) { label.setHorizontalAlignment(JLabel.CENTER); label.setText(value != null ? value.toString() : ""); } else if (columnName.equals("Ausreißer?")) { label.setHorizontalAlignment(JLabel.CENTER); label.setText(value != null ? value.toString() : ""); } else { label.setText(value != null ? value.toString() : ""); } if (value == null) { label.setText(""); } } if (cellComponent instanceof JComponent) { JComponent jcomponent = (JComponent) cellComponent; boolean isFirstRowOfGroup = (modelRow == 0); if (modelRow > 0) { CalculatedDataPoint prevPoint = model.getDataPointAt(modelRow - 1); if (prevPoint != null && !point.getAusrichtung().equals(prevPoint.getAusrichtung())) { isFirstRowOfGroup = true; } } Border currentBorder = jcomponent.getBorder(); Border topBorder = isFirstRowOfGroup && modelRow > 0 ? BorderFactory.createMatteBorder(1, 0, 0, 0, SEPARATOR_COLOR) : null; jcomponent.setBorder(topBorder != null ? BorderFactory.createCompoundBorder(topBorder, currentBorder != null ? currentBorder : noFocusBorder) : (currentBorder != null ? currentBorder : noFocusBorder) ); } } cellComponent.setBackground(finalBackground); cellComponent.setForeground(finalForeground); return cellComponent; }
    }
}